var SapphireTimeUtilities = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

  // ../utilities/dist/chunk-G5GHKT7C.mjs
  var __defProp2 = Object.defineProperty;
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");

  // ../utilities/dist/lib/range.mjs
  function range(min, max, step) {
    return new Array(Math.floor((max - min) / step) + 1).fill(0).map((_val, i) => min + i * step);
  }
  __name(range, "range");
  __name2(range, "range");

  // ../cron/dist/index.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name3 = /* @__PURE__ */ __name((target, value) => __defProp3(target, "name", { value, configurable: true }), "__name");
  var __publicField = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  var partRegex = /^(?:(\*)|(\d+)(?:-(\d+))?)(?:\/(\d+))?$/;
  var wildcardRegex = /\bh\b|\B\?\B/g;
  var allowedNum = [
    [0, 59],
    [0, 23],
    [1, 31],
    [1, 12],
    [0, 6]
  ];
  var predefined = {
    "@annually": "0 0 1 1 *",
    "@yearly": "0 0 1 1 *",
    "@monthly": "0 0 1 * *",
    "@weekly": "0 0 * * 0",
    "@daily": "0 0 * * *",
    "@hourly": "0 * * * *"
  };
  var cronTokens = {
    jan: 1,
    feb: 2,
    mar: 3,
    apr: 4,
    may: 5,
    jun: 6,
    jul: 7,
    aug: 8,
    sep: 9,
    oct: 10,
    nov: 11,
    dec: 12,
    sun: 0,
    mon: 1,
    tue: 2,
    wed: 3,
    thu: 4,
    fri: 5,
    sat: 6
  };
  var tokensRegex = new RegExp(Object.keys(cronTokens).join("|"), "g");
  var _a;
  var _Cron = (_a = class {
    /**
     * @param cron The cron pattern to use
     */
    constructor(cron) {
      __publicField(this, "cron");
      __publicField(this, "normalized");
      __publicField(this, "minutes");
      __publicField(this, "hours");
      __publicField(this, "days");
      __publicField(this, "months");
      __publicField(this, "dows");
      this.cron = cron.toLowerCase();
      this.normalized = _a.normalize(this.cron);
      [this.minutes, this.hours, this.days, this.months, this.dows] = _a.parseString(this.normalized);
    }
    /**
     * Get the next date that matches with the current pattern
     * @param outset The Date instance to compare with
     * @param origin Whether this next call is origin
     */
    next(outset = /* @__PURE__ */ new Date(), origin = true) {
      if (!this.days.includes(outset.getUTCDate()) || !this.months.includes(outset.getUTCMonth() + 1) || !this.dows.includes(outset.getUTCDay())) {
        return this.next(new Date(
          outset.getTime() + 864e5
          /* Day */
        ), false);
      }
      if (!origin)
        return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), this.hours[0], this.minutes[0]));
      const now = new Date(outset.getTime() + 6e4);
      for (const hour of this.hours) {
        if (hour < now.getUTCHours())
          continue;
        for (const minute of this.minutes) {
          if (hour === now.getUTCHours() && minute < now.getUTCMinutes())
            continue;
          return new Date(Date.UTC(outset.getUTCFullYear(), outset.getUTCMonth(), outset.getUTCDate(), hour, minute));
        }
      }
      return this.next(new Date(
        outset.getTime() + 864e5
        /* Day */
      ), false);
    }
    /**
     * Normalize the pattern
     * @param cron The pattern to normalize
     */
    static normalize(cron) {
      if (Reflect.has(predefined, cron))
        return Reflect.get(predefined, cron);
      const now = /* @__PURE__ */ new Date();
      cron = cron.split(" ").map(
        (val, i) => val.replace(wildcardRegex, (match) => {
          if (match === "h")
            return (Math.floor(Math.random() * allowedNum[i][1]) + allowedNum[i][0]).toString();
          if (match === "?") {
            switch (i) {
              case 0:
                return now.getUTCMinutes().toString();
              case 1:
                return now.getUTCHours().toString();
              case 2:
                return now.getUTCDate().toString();
              case 3:
                return now.getUTCMonth().toString();
              case 4:
                return now.getUTCDay().toString();
            }
          }
          return match;
        })
      ).join(" ");
      return cron.replace(tokensRegex, (match) => String(Reflect.get(cronTokens, match)));
    }
    /**
     * Parse the pattern
     * @param cron The pattern to parse
     */
    static parseString(cron) {
      const parts = cron.split(" ");
      if (parts.length !== 5)
        throw new Error("Invalid Cron Provided");
      return parts.map((part, i) => _a.parsePart(part, i));
    }
    /**
     * Parse the current part
     * @param cronPart The part of the pattern to parse
     * @param id The id that identifies the current part
     */
    static parsePart(cronPart, id) {
      if (cronPart.includes(",")) {
        const res = [];
        for (const part of cronPart.split(","))
          res.push(..._a.parsePart(part, id));
        return [...new Set(res)].sort((a, b) => a - b);
      }
      const [, wild, minStr, maxStr, step] = partRegex.exec(cronPart);
      let [min, max] = [parseInt(minStr, 10), parseInt(maxStr, 10)];
      if (wild)
        [min, max] = allowedNum[id];
      else if (!max && !step)
        return [min];
      [min, max] = [min, max || allowedNum[id][1]].sort((a, b) => a - b);
      return range(min, max, parseInt(step, 10) || 1);
    }
  }, __name(_a, "_Cron"), _a);
  __name3(_Cron, "Cron");
  var Cron = _Cron;

  // ../duration/dist/index.mjs
  var __defProp4 = Object.defineProperty;
  var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name4 = /* @__PURE__ */ __name((target, value) => __defProp4(target, "name", { value, configurable: true }), "__name");
  var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  var Time = /* @__PURE__ */ ((Time2) => {
    Time2[Time2["Nanosecond"] = 1e-6] = "Nanosecond";
    Time2[Time2["Microsecond"] = 1e-3] = "Microsecond";
    Time2[Time2["Millisecond"] = 1] = "Millisecond";
    Time2[Time2["Second"] = 1e3] = "Second";
    Time2[Time2["Minute"] = 6e4] = "Minute";
    Time2[Time2["Hour"] = 36e5] = "Hour";
    Time2[Time2["Day"] = 864e5] = "Day";
    Time2[Time2["Week"] = 6048e5] = "Week";
    Time2[Time2["Month"] = 2628e6] = "Month";
    Time2[Time2["Year"] = 31536e6] = "Year";
    return Time2;
  })(Time || {});
  var TimeTypes = /* @__PURE__ */ ((TimeTypes2) => {
    TimeTypes2["Second"] = "second";
    TimeTypes2["Minute"] = "minute";
    TimeTypes2["Hour"] = "hour";
    TimeTypes2["Day"] = "day";
    TimeTypes2["Week"] = "week";
    TimeTypes2["Month"] = "month";
    TimeTypes2["Year"] = "year";
    return TimeTypes2;
  })(TimeTypes || {});
  var DEFAULT_UNITS = {
    [
      "year"
      /* Year */
    ]: {
      1: "year",
      DEFAULT: "years"
    },
    [
      "month"
      /* Month */
    ]: {
      1: "month",
      DEFAULT: "months"
    },
    [
      "week"
      /* Week */
    ]: {
      1: "week",
      DEFAULT: "weeks"
    },
    [
      "day"
      /* Day */
    ]: {
      1: "day",
      DEFAULT: "days"
    },
    [
      "hour"
      /* Hour */
    ]: {
      1: "hour",
      DEFAULT: "hours"
    },
    [
      "minute"
      /* Minute */
    ]: {
      1: "minute",
      DEFAULT: "minutes"
    },
    [
      "second"
      /* Second */
    ]: {
      1: "second",
      DEFAULT: "seconds"
    }
  };
  var DEFAULT_SEPARATORS = {
    left: " ",
    right: " "
  };
  var tokens = /* @__PURE__ */ new Map([
    [
      "nanosecond",
      1e-6
      /* Nanosecond */
    ],
    [
      "nanoseconds",
      1e-6
      /* Nanosecond */
    ],
    [
      "ns",
      1e-6
      /* Nanosecond */
    ],
    [
      "microsecond",
      1e-3
      /* Microsecond */
    ],
    [
      "microseconds",
      1e-3
      /* Microsecond */
    ],
    [
      "\u03BCs",
      1e-3
      /* Microsecond */
    ],
    [
      "us",
      1e-3
      /* Microsecond */
    ],
    [
      "millisecond",
      1
      /* Millisecond */
    ],
    [
      "milliseconds",
      1
      /* Millisecond */
    ],
    [
      "ms",
      1
      /* Millisecond */
    ],
    [
      "second",
      1e3
      /* Second */
    ],
    [
      "seconds",
      1e3
      /* Second */
    ],
    [
      "sec",
      1e3
      /* Second */
    ],
    [
      "secs",
      1e3
      /* Second */
    ],
    [
      "s",
      1e3
      /* Second */
    ],
    [
      "minute",
      6e4
      /* Minute */
    ],
    [
      "minutes",
      6e4
      /* Minute */
    ],
    [
      "min",
      6e4
      /* Minute */
    ],
    [
      "mins",
      6e4
      /* Minute */
    ],
    [
      "m",
      6e4
      /* Minute */
    ],
    [
      "hour",
      36e5
      /* Hour */
    ],
    [
      "hours",
      36e5
      /* Hour */
    ],
    [
      "hr",
      36e5
      /* Hour */
    ],
    [
      "hrs",
      36e5
      /* Hour */
    ],
    [
      "h",
      36e5
      /* Hour */
    ],
    [
      "day",
      864e5
      /* Day */
    ],
    [
      "days",
      864e5
      /* Day */
    ],
    [
      "d",
      864e5
      /* Day */
    ],
    [
      "week",
      6048e5
      /* Week */
    ],
    [
      "weeks",
      6048e5
      /* Week */
    ],
    [
      "wk",
      6048e5
      /* Week */
    ],
    [
      "wks",
      6048e5
      /* Week */
    ],
    [
      "w",
      6048e5
      /* Week */
    ],
    [
      "month",
      2628e6
      /* Month */
    ],
    [
      "months",
      2628e6
      /* Month */
    ],
    [
      "b",
      2628e6
      /* Month */
    ],
    [
      "mo",
      2628e6
      /* Month */
    ],
    [
      "year",
      31536e6
      /* Year */
    ],
    [
      "years",
      31536e6
      /* Year */
    ],
    [
      "yr",
      31536e6
      /* Year */
    ],
    [
      "yrs",
      31536e6
      /* Year */
    ],
    [
      "y",
      31536e6
      /* Year */
    ]
  ]);
  var mappings = /* @__PURE__ */ new Map([
    [1e-6, "nanoseconds"],
    [1e-3, "microseconds"],
    [1, "milliseconds"],
    [1e3, "seconds"],
    [6e4, "minutes"],
    [36e5, "hours"],
    [864e5, "days"],
    [6048e5, "weeks"],
    [2628e6, "months"],
    [31536e6, "years"]
  ]);
  var _a2;
  var _Duration = (_a2 = class {
    /**
     * Create a new Duration instance
     * @param pattern The string to parse
     */
    constructor(pattern) {
      __publicField2(this, "offset");
      __publicField2(this, "nanoseconds", 0);
      __publicField2(this, "microseconds", 0);
      __publicField2(this, "milliseconds", 0);
      __publicField2(this, "seconds", 0);
      __publicField2(this, "minutes", 0);
      __publicField2(this, "hours", 0);
      __publicField2(this, "days", 0);
      __publicField2(this, "weeks", 0);
      __publicField2(this, "months", 0);
      __publicField2(this, "years", 0);
      let result = 0;
      let valid = false;
      pattern.toLowerCase().replace(_a2.commaRegex, "").replace(_a2.aAndAnRegex, "1").replace(_a2.patternRegex, (_, i, units) => {
        const token = tokens.get(units);
        if (token !== void 0) {
          const n = Number(i);
          result += n * token;
          this[mappings.get(token)] += n;
          valid = true;
        }
        return "";
      });
      this.offset = valid ? result : NaN;
    }
    /**
     * Get the date from now
     */
    get fromNow() {
      return this.dateFrom(/* @__PURE__ */ new Date());
    }
    /**
     * Get the date from
     * @param date The Date instance to get the date from
     */
    dateFrom(date) {
      return new Date(date.getTime() + this.offset);
    }
  }, __name(_a2, "_Duration"), _a2);
  __name4(_Duration, "Duration");
  __publicField2(_Duration, "patternRegex", /(-?\d*\.?\d+(?:e[-+]?\d+)?)\s*([a-zμ]*)/gi);
  __publicField2(_Duration, "commaRegex", /,/g);
  __publicField2(_Duration, "aAndAnRegex", /\ban?\b/gi);
  var Duration = _Duration;
  var kTimeDurations = [
    ["year", 31536e6],
    // 29.53059 days is the official duration of a month: https://en.wikipedia.org/wiki/Month
    ["month", 2628e6],
    ["week", 1e3 * 60 * 60 * 24 * 7],
    ["day", 1e3 * 60 * 60 * 24],
    ["hour", 1e3 * 60 * 60],
    ["minute", 1e3 * 60],
    ["second", 1e3]
  ];
  var _a3;
  var _DurationFormatter = (_a3 = class {
    constructor(units = DEFAULT_UNITS) {
      this.units = units;
    }
    format(duration, precision = 7, {
      left: leftSeparator = DEFAULT_SEPARATORS.left,
      right: rightSeparator = DEFAULT_SEPARATORS.right
    } = DEFAULT_SEPARATORS) {
      const output = [];
      const negative = duration < 0;
      if (negative)
        duration *= -1;
      for (const [type, timeDuration] of kTimeDurations) {
        const division = duration / timeDuration;
        if (division < 1)
          continue;
        const floored = Math.floor(division);
        duration -= floored * timeDuration;
        output.push(addUnit(floored, this.units[type], leftSeparator));
        if (output.length >= precision)
          break;
      }
      return `${negative ? "-" : ""}${output.join(rightSeparator) || addUnit(0, this.units.second, leftSeparator)}`;
    }
  }, __name(_a3, "_DurationFormatter"), _a3);
  __name4(_DurationFormatter, "DurationFormatter");
  var DurationFormatter = _DurationFormatter;
  function addUnit(time, unit, separator) {
    if (Reflect.has(unit, time))
      return `${time}${separator}${Reflect.get(unit, time)}`;
    return `${time}${separator}${unit.DEFAULT}`;
  }
  __name(addUnit, "addUnit");
  __name4(addUnit, "addUnit");

  // ../timer-manager/dist/index.mjs
  var __defProp5 = Object.defineProperty;
  var __defNormalProp3 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name5 = /* @__PURE__ */ __name((target, value) => __defProp5(target, "name", { value, configurable: true }), "__name");
  var __publicField3 = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  var _a4;
  var _TimerManager = (_a4 = class extends null {
    /**
     * Creates a timeout gets cleared when destroyed
     * @param fn callback function
     * @param delay amount of time before running the callback
     * @param args additional arguments to pass back to the callback
     */
    static setTimeout(fn, delay, ...args) {
      const timeout = setTimeout(() => {
        this.storedTimeouts.delete(timeout);
        fn(...args);
      }, delay);
      this.storedTimeouts.add(timeout);
      return timeout;
    }
    /**
     * Clears a timeout created through this class
     * @param timeout The timeout to clear
     */
    static clearTimeout(timeout) {
      clearTimeout(timeout);
      this.storedTimeouts.delete(timeout);
    }
    /**
     * Creates an interval gets cleared when destroyed
     * @param fn callback function
     * @param delay amount of time before running the callback
     * @param args additional arguments to pass back to the callback
     */
    static setInterval(fn, delay, ...args) {
      const interval = setInterval(fn, delay, ...args);
      this.storedIntervals.add(interval);
      return interval;
    }
    /**
     * Clears an internal created through this class
     * @param interval The interval to clear
     */
    static clearInterval(interval) {
      clearInterval(interval);
      this.storedIntervals.delete(interval);
    }
    /**
     * Clears running timeouts and intervals created through this class so NodeJS can gracefully exit
     */
    static destroy() {
      for (const i of this.storedTimeouts)
        clearTimeout(i);
      for (const i of this.storedIntervals)
        clearInterval(i);
      this.storedTimeouts.clear();
      this.storedIntervals.clear();
    }
  }, __name(_a4, "_TimerManager"), _a4);
  __name5(_TimerManager, "TimerManager");
  __publicField3(_TimerManager, "storedTimeouts", /* @__PURE__ */ new Set());
  __publicField3(_TimerManager, "storedIntervals", /* @__PURE__ */ new Set());
  var TimerManager = _TimerManager;

  // ../timestamp/dist/index.mjs
  var __defProp6 = Object.defineProperty;
  var __defNormalProp4 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name6 = /* @__PURE__ */ __name((target, value) => __defProp6(target, "name", { value, configurable: true }), "__name");
  var __publicField4 = /* @__PURE__ */ __name((obj, key, value) => {
    __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  }, "__publicField");
  var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var tokens2 = /* @__PURE__ */ new Map([
    ["Y", 4],
    ["Q", 1],
    ["M", 4],
    ["D", 4],
    ["d", 4],
    ["X", 1],
    ["x", 1],
    ["H", 2],
    ["h", 2],
    ["a", 1],
    ["A", 1],
    ["m", 2],
    ["s", 2],
    ["S", 3],
    ["Z", 2],
    ["l", 4],
    ["L", 4],
    ["T", 1],
    ["t", 1]
  ]);
  var tokenResolvers = /* @__PURE__ */ new Map([
    // Dates
    ["Y", (time) => String(time.getFullYear()).slice(2)],
    ["YY", (time) => String(time.getFullYear()).slice(2)],
    ["YYY", (time) => String(time.getFullYear())],
    ["YYYY", (time) => String(time.getFullYear())],
    ["Q", (time) => String((time.getMonth() + 1) / 3)],
    ["M", (time) => String(time.getMonth() + 1)],
    ["MM", (time) => String(time.getMonth() + 1).padStart(2, "0")],
    ["MMM", (time) => months[time.getMonth()]],
    ["MMMM", (time) => months[time.getMonth()]],
    ["D", (time) => String(time.getDate())],
    ["DD", (time) => String(time.getDate()).padStart(2, "0")],
    ["DDD", (time) => String(Math.floor(
      (time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5
      /* Day */
    ))],
    ["DDDD", (time) => String(Math.floor(
      (time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5
      /* Day */
    ))],
    [
      "d",
      (time) => {
        const day = String(time.getDate());
        if (day !== "11" && day.endsWith("1"))
          return `${day}st`;
        if (day !== "12" && day.endsWith("2"))
          return `${day}nd`;
        if (day !== "13" && day.endsWith("3"))
          return `${day}rd`;
        return `${day}th`;
      }
    ],
    ["dd", (time) => days[time.getDay()].slice(0, 2)],
    ["ddd", (time) => days[time.getDay()].slice(0, 3)],
    ["dddd", (time) => days[time.getDay()]],
    ["X", (time) => String(
      time.valueOf() / 1e3
      /* Second */
    )],
    ["x", (time) => String(time.valueOf())],
    // Locales
    ["H", (time) => String(time.getHours())],
    ["HH", (time) => String(time.getHours()).padStart(2, "0")],
    ["h", (time) => String(time.getHours() % 12 || 12)],
    ["hh", (time) => String(time.getHours() % 12 || 12).padStart(2, "0")],
    ["a", (time) => time.getHours() < 12 ? "am" : "pm"],
    ["A", (time) => time.getHours() < 12 ? "AM" : "PM"],
    ["m", (time) => String(time.getMinutes())],
    ["mm", (time) => String(time.getMinutes()).padStart(2, "0")],
    ["s", (time) => String(time.getSeconds())],
    ["ss", (time) => String(time.getSeconds()).padStart(2, "0")],
    ["S", (time) => String(time.getMilliseconds())],
    ["SS", (time) => String(time.getMilliseconds()).padStart(2, "0")],
    ["SSS", (time) => String(time.getMilliseconds()).padStart(3, "0")],
    ["T", (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`],
    [
      "t",
      (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")}:${String(time.getSeconds()).padStart(2, "0")} ${time.getHours() < 12 ? "am" : "pm"}`
    ],
    ["L", (time) => `${String(time.getMonth() + 1).padStart(2, "0")}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
    ["l", (time) => `${String(time.getMonth() + 1)}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
    ["LL", (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
    ["ll", (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
    [
      "LLL",
      (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(
      time.getHours() % 12 || 12
    )}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "lll",
      (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(
      time.getHours() % 12 || 12
    )}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "LLLL",
      (time) => `${days[time.getDay()]}, ${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(
      time.getHours() % 12 || 12
    )}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "llll",
      (time) => `${days[time.getDay()].slice(0, 3)} ${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(
      time.getFullYear()
    )} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "Z",
      (time) => {
        const offset = time.getTimezoneOffset();
        const unsigned = offset >= 0;
        const absolute = Math.abs(offset);
        return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
      }
    ],
    [
      "ZZ",
      (time) => {
        const offset = time.getTimezoneOffset();
        const unsigned = offset >= 0;
        const absolute = Math.abs(offset);
        return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
      }
    ]
  ]);
  var _a5;
  var _Timestamp = (_a5 = class {
    /**
     * Starts a new Timestamp and parses the pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     */
    constructor(pattern) {
      __publicField4(this, "pattern");
      __publicField4(this, "template");
      this.pattern = pattern;
      this.template = _a5.parse(pattern);
    }
    /**
     * Display the current date with the current pattern.
     * @since 1.0.0
     * @param time The time to display
     */
    display(time = /* @__PURE__ */ new Date()) {
      return _a5.display(this.template, time);
    }
    /**
     * Display the current date utc with the current pattern.
     * @since 1.0.0
     * @param time The time to display in utc
     */
    displayUTC(time) {
      return _a5.display(this.template, _a5.utc(time));
    }
    /**
     * Edits the current pattern.
     * @since 1.0.0
     * @param pattern The new pattern for this instance
     * @chainable
     */
    edit(pattern) {
      this.pattern = pattern;
      this.template = _a5.parse(pattern);
      return this;
    }
    /**
     * Defines the toString behavior of Timestamp.
     */
    toString() {
      return this.display();
    }
    /**
     * Display the current date with the current pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     * @param time The time to display
     */
    static displayArbitrary(pattern, time = /* @__PURE__ */ new Date()) {
      return _a5.display(_a5.parse(pattern), time);
    }
    /**
     * Display the current date utc with the current pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     * @param time The time to display
     */
    static displayUTCArbitrary(pattern, time = /* @__PURE__ */ new Date()) {
      return _a5.display(_a5.parse(pattern), _a5.utc(time));
    }
    /**
     * Creates a UTC Date object to work with.
     * @since 1.0.0
     * @param time The date to convert to utc
     */
    static utc(time = /* @__PURE__ */ new Date()) {
      time = _a5.resolveDate(time);
      return new Date(time.valueOf() + time.getTimezoneOffset() * 6e4);
    }
    /**
     * Display the current date with the current pattern.
     * @since 1.0.0
     * @param template The pattern to parse
     * @param time The time to display
     */
    static display(template, time) {
      let output = "";
      const parsedTime = _a5.resolveDate(time);
      for (const { content, type } of template)
        output += content || tokenResolvers.get(type)(parsedTime);
      return output;
    }
    /**
     * Parses the pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     */
    static parse(pattern) {
      const template = [];
      for (let i = 0; i < pattern.length; i++) {
        let current = "";
        const currentChar = pattern[i];
        const tokenMax = tokens2.get(currentChar);
        if (typeof tokenMax === "number") {
          current += currentChar;
          while (pattern[i + 1] === currentChar && current.length < tokenMax)
            current += pattern[++i];
          template.push({ type: current, content: null });
        } else if (currentChar === "[") {
          while (i + 1 < pattern.length && pattern[i + 1] !== "]")
            current += pattern[++i];
          i++;
          template.push({ type: "literal", content: current || "[" });
        } else {
          current += currentChar;
          while (i + 1 < pattern.length && !tokens2.has(pattern[i + 1]) && pattern[i + 1] !== "[")
            current += pattern[++i];
          template.push({ type: "literal", content: current });
        }
      }
      return template;
    }
    /**
     * Resolves a date.
     * @since 1.0.0
     * @param time The time to parse
     */
    static resolveDate(time) {
      return time instanceof Date ? time : new Date(time);
    }
  }, __name(_a5, "_Timestamp"), _a5);
  __name6(_Timestamp, "Timestamp");
  var Timestamp = _Timestamp;

  exports.Cron = Cron;
  exports.DEFAULT_SEPARATORS = DEFAULT_SEPARATORS;
  exports.DEFAULT_UNITS = DEFAULT_UNITS;
  exports.Duration = Duration;
  exports.DurationFormatter = DurationFormatter;
  exports.Time = Time;
  exports.TimeTypes = TimeTypes;
  exports.TimerManager = TimerManager;
  exports.Timestamp = Timestamp;
  exports.allowedNum = allowedNum;
  exports.cronTokens = cronTokens;
  exports.days = days;
  exports.months = months;
  exports.partRegex = partRegex;
  exports.predefined = predefined;
  exports.tokens = tokens2;
  exports.tokensRegex = tokensRegex;
  exports.wildcardRegex = wildcardRegex;

  return exports;

})({});
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.global.js.map